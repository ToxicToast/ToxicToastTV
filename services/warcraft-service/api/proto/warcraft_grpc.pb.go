// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: api/proto/warcraft.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CharacterService_CreateCharacter_FullMethodName       = "/warcraft.CharacterService/CreateCharacter"
	CharacterService_GetCharacter_FullMethodName          = "/warcraft.CharacterService/GetCharacter"
	CharacterService_ListCharacters_FullMethodName        = "/warcraft.CharacterService/ListCharacters"
	CharacterService_UpdateCharacter_FullMethodName       = "/warcraft.CharacterService/UpdateCharacter"
	CharacterService_DeleteCharacter_FullMethodName       = "/warcraft.CharacterService/DeleteCharacter"
	CharacterService_RefreshCharacter_FullMethodName      = "/warcraft.CharacterService/RefreshCharacter"
	CharacterService_GetCharacterEquipment_FullMethodName = "/warcraft.CharacterService/GetCharacterEquipment"
	CharacterService_GetCharacterStats_FullMethodName     = "/warcraft.CharacterService/GetCharacterStats"
)

// CharacterServiceClient is the client API for CharacterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CharacterServiceClient interface {
	CreateCharacter(ctx context.Context, in *CreateCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error)
	GetCharacter(ctx context.Context, in *GetCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error)
	ListCharacters(ctx context.Context, in *ListCharactersRequest, opts ...grpc.CallOption) (*ListCharactersResponse, error)
	UpdateCharacter(ctx context.Context, in *UpdateCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error)
	DeleteCharacter(ctx context.Context, in *DeleteCharacterRequest, opts ...grpc.CallOption) (*DeleteCharacterResponse, error)
	RefreshCharacter(ctx context.Context, in *RefreshCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error)
	GetCharacterEquipment(ctx context.Context, in *GetCharacterEquipmentRequest, opts ...grpc.CallOption) (*CharacterEquipmentResponse, error)
	GetCharacterStats(ctx context.Context, in *GetCharacterStatsRequest, opts ...grpc.CallOption) (*CharacterStatsResponse, error)
}

type characterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCharacterServiceClient(cc grpc.ClientConnInterface) CharacterServiceClient {
	return &characterServiceClient{cc}
}

func (c *characterServiceClient) CreateCharacter(ctx context.Context, in *CreateCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterResponse)
	err := c.cc.Invoke(ctx, CharacterService_CreateCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) GetCharacter(ctx context.Context, in *GetCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterResponse)
	err := c.cc.Invoke(ctx, CharacterService_GetCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) ListCharacters(ctx context.Context, in *ListCharactersRequest, opts ...grpc.CallOption) (*ListCharactersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCharactersResponse)
	err := c.cc.Invoke(ctx, CharacterService_ListCharacters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) UpdateCharacter(ctx context.Context, in *UpdateCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterResponse)
	err := c.cc.Invoke(ctx, CharacterService_UpdateCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) DeleteCharacter(ctx context.Context, in *DeleteCharacterRequest, opts ...grpc.CallOption) (*DeleteCharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCharacterResponse)
	err := c.cc.Invoke(ctx, CharacterService_DeleteCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) RefreshCharacter(ctx context.Context, in *RefreshCharacterRequest, opts ...grpc.CallOption) (*CharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterResponse)
	err := c.cc.Invoke(ctx, CharacterService_RefreshCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) GetCharacterEquipment(ctx context.Context, in *GetCharacterEquipmentRequest, opts ...grpc.CallOption) (*CharacterEquipmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterEquipmentResponse)
	err := c.cc.Invoke(ctx, CharacterService_GetCharacterEquipment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *characterServiceClient) GetCharacterStats(ctx context.Context, in *GetCharacterStatsRequest, opts ...grpc.CallOption) (*CharacterStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CharacterStatsResponse)
	err := c.cc.Invoke(ctx, CharacterService_GetCharacterStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CharacterServiceServer is the server API for CharacterService service.
// All implementations must embed UnimplementedCharacterServiceServer
// for forward compatibility.
type CharacterServiceServer interface {
	CreateCharacter(context.Context, *CreateCharacterRequest) (*CharacterResponse, error)
	GetCharacter(context.Context, *GetCharacterRequest) (*CharacterResponse, error)
	ListCharacters(context.Context, *ListCharactersRequest) (*ListCharactersResponse, error)
	UpdateCharacter(context.Context, *UpdateCharacterRequest) (*CharacterResponse, error)
	DeleteCharacter(context.Context, *DeleteCharacterRequest) (*DeleteCharacterResponse, error)
	RefreshCharacter(context.Context, *RefreshCharacterRequest) (*CharacterResponse, error)
	GetCharacterEquipment(context.Context, *GetCharacterEquipmentRequest) (*CharacterEquipmentResponse, error)
	GetCharacterStats(context.Context, *GetCharacterStatsRequest) (*CharacterStatsResponse, error)
	mustEmbedUnimplementedCharacterServiceServer()
}

// UnimplementedCharacterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCharacterServiceServer struct{}

func (UnimplementedCharacterServiceServer) CreateCharacter(context.Context, *CreateCharacterRequest) (*CharacterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCharacter not implemented")
}
func (UnimplementedCharacterServiceServer) GetCharacter(context.Context, *GetCharacterRequest) (*CharacterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCharacter not implemented")
}
func (UnimplementedCharacterServiceServer) ListCharacters(context.Context, *ListCharactersRequest) (*ListCharactersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCharacters not implemented")
}
func (UnimplementedCharacterServiceServer) UpdateCharacter(context.Context, *UpdateCharacterRequest) (*CharacterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCharacter not implemented")
}
func (UnimplementedCharacterServiceServer) DeleteCharacter(context.Context, *DeleteCharacterRequest) (*DeleteCharacterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCharacter not implemented")
}
func (UnimplementedCharacterServiceServer) RefreshCharacter(context.Context, *RefreshCharacterRequest) (*CharacterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshCharacter not implemented")
}
func (UnimplementedCharacterServiceServer) GetCharacterEquipment(context.Context, *GetCharacterEquipmentRequest) (*CharacterEquipmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCharacterEquipment not implemented")
}
func (UnimplementedCharacterServiceServer) GetCharacterStats(context.Context, *GetCharacterStatsRequest) (*CharacterStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCharacterStats not implemented")
}
func (UnimplementedCharacterServiceServer) mustEmbedUnimplementedCharacterServiceServer() {}
func (UnimplementedCharacterServiceServer) testEmbeddedByValue()                          {}

// UnsafeCharacterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CharacterServiceServer will
// result in compilation errors.
type UnsafeCharacterServiceServer interface {
	mustEmbedUnimplementedCharacterServiceServer()
}

func RegisterCharacterServiceServer(s grpc.ServiceRegistrar, srv CharacterServiceServer) {
	// If the following call pancis, it indicates UnimplementedCharacterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CharacterService_ServiceDesc, srv)
}

func _CharacterService_CreateCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).CreateCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_CreateCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).CreateCharacter(ctx, req.(*CreateCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_GetCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).GetCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_GetCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).GetCharacter(ctx, req.(*GetCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_ListCharacters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCharactersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).ListCharacters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_ListCharacters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).ListCharacters(ctx, req.(*ListCharactersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_UpdateCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).UpdateCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_UpdateCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).UpdateCharacter(ctx, req.(*UpdateCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_DeleteCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).DeleteCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_DeleteCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).DeleteCharacter(ctx, req.(*DeleteCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_RefreshCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).RefreshCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_RefreshCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).RefreshCharacter(ctx, req.(*RefreshCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_GetCharacterEquipment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCharacterEquipmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).GetCharacterEquipment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_GetCharacterEquipment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).GetCharacterEquipment(ctx, req.(*GetCharacterEquipmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CharacterService_GetCharacterStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCharacterStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CharacterServiceServer).GetCharacterStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CharacterService_GetCharacterStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CharacterServiceServer).GetCharacterStats(ctx, req.(*GetCharacterStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CharacterService_ServiceDesc is the grpc.ServiceDesc for CharacterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CharacterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warcraft.CharacterService",
	HandlerType: (*CharacterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCharacter",
			Handler:    _CharacterService_CreateCharacter_Handler,
		},
		{
			MethodName: "GetCharacter",
			Handler:    _CharacterService_GetCharacter_Handler,
		},
		{
			MethodName: "ListCharacters",
			Handler:    _CharacterService_ListCharacters_Handler,
		},
		{
			MethodName: "UpdateCharacter",
			Handler:    _CharacterService_UpdateCharacter_Handler,
		},
		{
			MethodName: "DeleteCharacter",
			Handler:    _CharacterService_DeleteCharacter_Handler,
		},
		{
			MethodName: "RefreshCharacter",
			Handler:    _CharacterService_RefreshCharacter_Handler,
		},
		{
			MethodName: "GetCharacterEquipment",
			Handler:    _CharacterService_GetCharacterEquipment_Handler,
		},
		{
			MethodName: "GetCharacterStats",
			Handler:    _CharacterService_GetCharacterStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/warcraft.proto",
}

const (
	RaceService_ListRaces_FullMethodName = "/warcraft.RaceService/ListRaces"
	RaceService_GetRace_FullMethodName   = "/warcraft.RaceService/GetRace"
)

// RaceServiceClient is the client API for RaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaceServiceClient interface {
	ListRaces(ctx context.Context, in *ListRacesRequest, opts ...grpc.CallOption) (*ListRacesResponse, error)
	GetRace(ctx context.Context, in *GetRaceRequest, opts ...grpc.CallOption) (*RaceResponse, error)
}

type raceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRaceServiceClient(cc grpc.ClientConnInterface) RaceServiceClient {
	return &raceServiceClient{cc}
}

func (c *raceServiceClient) ListRaces(ctx context.Context, in *ListRacesRequest, opts ...grpc.CallOption) (*ListRacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRacesResponse)
	err := c.cc.Invoke(ctx, RaceService_ListRaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceServiceClient) GetRace(ctx context.Context, in *GetRaceRequest, opts ...grpc.CallOption) (*RaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RaceResponse)
	err := c.cc.Invoke(ctx, RaceService_GetRace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaceServiceServer is the server API for RaceService service.
// All implementations must embed UnimplementedRaceServiceServer
// for forward compatibility.
type RaceServiceServer interface {
	ListRaces(context.Context, *ListRacesRequest) (*ListRacesResponse, error)
	GetRace(context.Context, *GetRaceRequest) (*RaceResponse, error)
	mustEmbedUnimplementedRaceServiceServer()
}

// UnimplementedRaceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRaceServiceServer struct{}

func (UnimplementedRaceServiceServer) ListRaces(context.Context, *ListRacesRequest) (*ListRacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRaces not implemented")
}
func (UnimplementedRaceServiceServer) GetRace(context.Context, *GetRaceRequest) (*RaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRace not implemented")
}
func (UnimplementedRaceServiceServer) mustEmbedUnimplementedRaceServiceServer() {}
func (UnimplementedRaceServiceServer) testEmbeddedByValue()                     {}

// UnsafeRaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaceServiceServer will
// result in compilation errors.
type UnsafeRaceServiceServer interface {
	mustEmbedUnimplementedRaceServiceServer()
}

func RegisterRaceServiceServer(s grpc.ServiceRegistrar, srv RaceServiceServer) {
	// If the following call pancis, it indicates UnimplementedRaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RaceService_ServiceDesc, srv)
}

func _RaceService_ListRaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServiceServer).ListRaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RaceService_ListRaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServiceServer).ListRaces(ctx, req.(*ListRacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaceService_GetRace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServiceServer).GetRace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RaceService_GetRace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServiceServer).GetRace(ctx, req.(*GetRaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RaceService_ServiceDesc is the grpc.ServiceDesc for RaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warcraft.RaceService",
	HandlerType: (*RaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRaces",
			Handler:    _RaceService_ListRaces_Handler,
		},
		{
			MethodName: "GetRace",
			Handler:    _RaceService_GetRace_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/warcraft.proto",
}

const (
	ClassService_ListClasses_FullMethodName = "/warcraft.ClassService/ListClasses"
	ClassService_GetClass_FullMethodName    = "/warcraft.ClassService/GetClass"
)

// ClassServiceClient is the client API for ClassService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClassServiceClient interface {
	ListClasses(ctx context.Context, in *ListClassesRequest, opts ...grpc.CallOption) (*ListClassesResponse, error)
	GetClass(ctx context.Context, in *GetClassRequest, opts ...grpc.CallOption) (*ClassResponse, error)
}

type classServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClassServiceClient(cc grpc.ClientConnInterface) ClassServiceClient {
	return &classServiceClient{cc}
}

func (c *classServiceClient) ListClasses(ctx context.Context, in *ListClassesRequest, opts ...grpc.CallOption) (*ListClassesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClassesResponse)
	err := c.cc.Invoke(ctx, ClassService_ListClasses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classServiceClient) GetClass(ctx context.Context, in *GetClassRequest, opts ...grpc.CallOption) (*ClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClassResponse)
	err := c.cc.Invoke(ctx, ClassService_GetClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClassServiceServer is the server API for ClassService service.
// All implementations must embed UnimplementedClassServiceServer
// for forward compatibility.
type ClassServiceServer interface {
	ListClasses(context.Context, *ListClassesRequest) (*ListClassesResponse, error)
	GetClass(context.Context, *GetClassRequest) (*ClassResponse, error)
	mustEmbedUnimplementedClassServiceServer()
}

// UnimplementedClassServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClassServiceServer struct{}

func (UnimplementedClassServiceServer) ListClasses(context.Context, *ListClassesRequest) (*ListClassesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClasses not implemented")
}
func (UnimplementedClassServiceServer) GetClass(context.Context, *GetClassRequest) (*ClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClass not implemented")
}
func (UnimplementedClassServiceServer) mustEmbedUnimplementedClassServiceServer() {}
func (UnimplementedClassServiceServer) testEmbeddedByValue()                      {}

// UnsafeClassServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClassServiceServer will
// result in compilation errors.
type UnsafeClassServiceServer interface {
	mustEmbedUnimplementedClassServiceServer()
}

func RegisterClassServiceServer(s grpc.ServiceRegistrar, srv ClassServiceServer) {
	// If the following call pancis, it indicates UnimplementedClassServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClassService_ServiceDesc, srv)
}

func _ClassService_ListClasses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClassesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServiceServer).ListClasses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassService_ListClasses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServiceServer).ListClasses(ctx, req.(*ListClassesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClassService_GetClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServiceServer).GetClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClassService_GetClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServiceServer).GetClass(ctx, req.(*GetClassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClassService_ServiceDesc is the grpc.ServiceDesc for ClassService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClassService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warcraft.ClassService",
	HandlerType: (*ClassServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListClasses",
			Handler:    _ClassService_ListClasses_Handler,
		},
		{
			MethodName: "GetClass",
			Handler:    _ClassService_GetClass_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/warcraft.proto",
}

const (
	FactionService_ListFactions_FullMethodName = "/warcraft.FactionService/ListFactions"
	FactionService_GetFaction_FullMethodName   = "/warcraft.FactionService/GetFaction"
)

// FactionServiceClient is the client API for FactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FactionServiceClient interface {
	ListFactions(ctx context.Context, in *ListFactionsRequest, opts ...grpc.CallOption) (*ListFactionsResponse, error)
	GetFaction(ctx context.Context, in *GetFactionRequest, opts ...grpc.CallOption) (*FactionResponse, error)
}

type factionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFactionServiceClient(cc grpc.ClientConnInterface) FactionServiceClient {
	return &factionServiceClient{cc}
}

func (c *factionServiceClient) ListFactions(ctx context.Context, in *ListFactionsRequest, opts ...grpc.CallOption) (*ListFactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFactionsResponse)
	err := c.cc.Invoke(ctx, FactionService_ListFactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *factionServiceClient) GetFaction(ctx context.Context, in *GetFactionRequest, opts ...grpc.CallOption) (*FactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FactionResponse)
	err := c.cc.Invoke(ctx, FactionService_GetFaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FactionServiceServer is the server API for FactionService service.
// All implementations must embed UnimplementedFactionServiceServer
// for forward compatibility.
type FactionServiceServer interface {
	ListFactions(context.Context, *ListFactionsRequest) (*ListFactionsResponse, error)
	GetFaction(context.Context, *GetFactionRequest) (*FactionResponse, error)
	mustEmbedUnimplementedFactionServiceServer()
}

// UnimplementedFactionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFactionServiceServer struct{}

func (UnimplementedFactionServiceServer) ListFactions(context.Context, *ListFactionsRequest) (*ListFactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFactions not implemented")
}
func (UnimplementedFactionServiceServer) GetFaction(context.Context, *GetFactionRequest) (*FactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFaction not implemented")
}
func (UnimplementedFactionServiceServer) mustEmbedUnimplementedFactionServiceServer() {}
func (UnimplementedFactionServiceServer) testEmbeddedByValue()                        {}

// UnsafeFactionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FactionServiceServer will
// result in compilation errors.
type UnsafeFactionServiceServer interface {
	mustEmbedUnimplementedFactionServiceServer()
}

func RegisterFactionServiceServer(s grpc.ServiceRegistrar, srv FactionServiceServer) {
	// If the following call pancis, it indicates UnimplementedFactionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FactionService_ServiceDesc, srv)
}

func _FactionService_ListFactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FactionServiceServer).ListFactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FactionService_ListFactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FactionServiceServer).ListFactions(ctx, req.(*ListFactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FactionService_GetFaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FactionServiceServer).GetFaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FactionService_GetFaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FactionServiceServer).GetFaction(ctx, req.(*GetFactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FactionService_ServiceDesc is the grpc.ServiceDesc for FactionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FactionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warcraft.FactionService",
	HandlerType: (*FactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFactions",
			Handler:    _FactionService_ListFactions_Handler,
		},
		{
			MethodName: "GetFaction",
			Handler:    _FactionService_GetFaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/warcraft.proto",
}

const (
	GuildService_CreateGuild_FullMethodName    = "/warcraft.GuildService/CreateGuild"
	GuildService_GetGuild_FullMethodName       = "/warcraft.GuildService/GetGuild"
	GuildService_ListGuilds_FullMethodName     = "/warcraft.GuildService/ListGuilds"
	GuildService_UpdateGuild_FullMethodName    = "/warcraft.GuildService/UpdateGuild"
	GuildService_DeleteGuild_FullMethodName    = "/warcraft.GuildService/DeleteGuild"
	GuildService_RefreshGuild_FullMethodName   = "/warcraft.GuildService/RefreshGuild"
	GuildService_GetGuildRoster_FullMethodName = "/warcraft.GuildService/GetGuildRoster"
)

// GuildServiceClient is the client API for GuildService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuildServiceClient interface {
	CreateGuild(ctx context.Context, in *CreateGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error)
	GetGuild(ctx context.Context, in *GetGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error)
	ListGuilds(ctx context.Context, in *ListGuildsRequest, opts ...grpc.CallOption) (*ListGuildsResponse, error)
	UpdateGuild(ctx context.Context, in *UpdateGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error)
	DeleteGuild(ctx context.Context, in *DeleteGuildRequest, opts ...grpc.CallOption) (*DeleteGuildResponse, error)
	RefreshGuild(ctx context.Context, in *RefreshGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error)
	GetGuildRoster(ctx context.Context, in *GetGuildRosterRequest, opts ...grpc.CallOption) (*GuildRosterResponse, error)
}

type guildServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGuildServiceClient(cc grpc.ClientConnInterface) GuildServiceClient {
	return &guildServiceClient{cc}
}

func (c *guildServiceClient) CreateGuild(ctx context.Context, in *CreateGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuildResponse)
	err := c.cc.Invoke(ctx, GuildService_CreateGuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) GetGuild(ctx context.Context, in *GetGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuildResponse)
	err := c.cc.Invoke(ctx, GuildService_GetGuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) ListGuilds(ctx context.Context, in *ListGuildsRequest, opts ...grpc.CallOption) (*ListGuildsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGuildsResponse)
	err := c.cc.Invoke(ctx, GuildService_ListGuilds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) UpdateGuild(ctx context.Context, in *UpdateGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuildResponse)
	err := c.cc.Invoke(ctx, GuildService_UpdateGuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) DeleteGuild(ctx context.Context, in *DeleteGuildRequest, opts ...grpc.CallOption) (*DeleteGuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGuildResponse)
	err := c.cc.Invoke(ctx, GuildService_DeleteGuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) RefreshGuild(ctx context.Context, in *RefreshGuildRequest, opts ...grpc.CallOption) (*GuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuildResponse)
	err := c.cc.Invoke(ctx, GuildService_RefreshGuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guildServiceClient) GetGuildRoster(ctx context.Context, in *GetGuildRosterRequest, opts ...grpc.CallOption) (*GuildRosterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuildRosterResponse)
	err := c.cc.Invoke(ctx, GuildService_GetGuildRoster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuildServiceServer is the server API for GuildService service.
// All implementations must embed UnimplementedGuildServiceServer
// for forward compatibility.
type GuildServiceServer interface {
	CreateGuild(context.Context, *CreateGuildRequest) (*GuildResponse, error)
	GetGuild(context.Context, *GetGuildRequest) (*GuildResponse, error)
	ListGuilds(context.Context, *ListGuildsRequest) (*ListGuildsResponse, error)
	UpdateGuild(context.Context, *UpdateGuildRequest) (*GuildResponse, error)
	DeleteGuild(context.Context, *DeleteGuildRequest) (*DeleteGuildResponse, error)
	RefreshGuild(context.Context, *RefreshGuildRequest) (*GuildResponse, error)
	GetGuildRoster(context.Context, *GetGuildRosterRequest) (*GuildRosterResponse, error)
	mustEmbedUnimplementedGuildServiceServer()
}

// UnimplementedGuildServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGuildServiceServer struct{}

func (UnimplementedGuildServiceServer) CreateGuild(context.Context, *CreateGuildRequest) (*GuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGuild not implemented")
}
func (UnimplementedGuildServiceServer) GetGuild(context.Context, *GetGuildRequest) (*GuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuild not implemented")
}
func (UnimplementedGuildServiceServer) ListGuilds(context.Context, *ListGuildsRequest) (*ListGuildsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGuilds not implemented")
}
func (UnimplementedGuildServiceServer) UpdateGuild(context.Context, *UpdateGuildRequest) (*GuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGuild not implemented")
}
func (UnimplementedGuildServiceServer) DeleteGuild(context.Context, *DeleteGuildRequest) (*DeleteGuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGuild not implemented")
}
func (UnimplementedGuildServiceServer) RefreshGuild(context.Context, *RefreshGuildRequest) (*GuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshGuild not implemented")
}
func (UnimplementedGuildServiceServer) GetGuildRoster(context.Context, *GetGuildRosterRequest) (*GuildRosterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuildRoster not implemented")
}
func (UnimplementedGuildServiceServer) mustEmbedUnimplementedGuildServiceServer() {}
func (UnimplementedGuildServiceServer) testEmbeddedByValue()                      {}

// UnsafeGuildServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuildServiceServer will
// result in compilation errors.
type UnsafeGuildServiceServer interface {
	mustEmbedUnimplementedGuildServiceServer()
}

func RegisterGuildServiceServer(s grpc.ServiceRegistrar, srv GuildServiceServer) {
	// If the following call pancis, it indicates UnimplementedGuildServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GuildService_ServiceDesc, srv)
}

func _GuildService_CreateGuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).CreateGuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_CreateGuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).CreateGuild(ctx, req.(*CreateGuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_GetGuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).GetGuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_GetGuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).GetGuild(ctx, req.(*GetGuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_ListGuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGuildsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).ListGuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_ListGuilds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).ListGuilds(ctx, req.(*ListGuildsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_UpdateGuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).UpdateGuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_UpdateGuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).UpdateGuild(ctx, req.(*UpdateGuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_DeleteGuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).DeleteGuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_DeleteGuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).DeleteGuild(ctx, req.(*DeleteGuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_RefreshGuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshGuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).RefreshGuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_RefreshGuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).RefreshGuild(ctx, req.(*RefreshGuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuildService_GetGuildRoster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuildRosterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuildServiceServer).GetGuildRoster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuildService_GetGuildRoster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuildServiceServer).GetGuildRoster(ctx, req.(*GetGuildRosterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GuildService_ServiceDesc is the grpc.ServiceDesc for GuildService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GuildService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warcraft.GuildService",
	HandlerType: (*GuildServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGuild",
			Handler:    _GuildService_CreateGuild_Handler,
		},
		{
			MethodName: "GetGuild",
			Handler:    _GuildService_GetGuild_Handler,
		},
		{
			MethodName: "ListGuilds",
			Handler:    _GuildService_ListGuilds_Handler,
		},
		{
			MethodName: "UpdateGuild",
			Handler:    _GuildService_UpdateGuild_Handler,
		},
		{
			MethodName: "DeleteGuild",
			Handler:    _GuildService_DeleteGuild_Handler,
		},
		{
			MethodName: "RefreshGuild",
			Handler:    _GuildService_RefreshGuild_Handler,
		},
		{
			MethodName: "GetGuildRoster",
			Handler:    _GuildService_GetGuildRoster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/warcraft.proto",
}
