// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: api/proto/twitchbot.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	StreamService_CreateStream_FullMethodName    = "/twitchbot.StreamService/CreateStream"
	StreamService_GetStream_FullMethodName       = "/twitchbot.StreamService/GetStream"
	StreamService_ListStreams_FullMethodName     = "/twitchbot.StreamService/ListStreams"
	StreamService_UpdateStream_FullMethodName    = "/twitchbot.StreamService/UpdateStream"
	StreamService_DeleteStream_FullMethodName    = "/twitchbot.StreamService/DeleteStream"
	StreamService_EndStream_FullMethodName       = "/twitchbot.StreamService/EndStream"
	StreamService_GetActiveStream_FullMethodName = "/twitchbot.StreamService/GetActiveStream"
	StreamService_GetStreamStats_FullMethodName  = "/twitchbot.StreamService/GetStreamStats"
)

// StreamServiceClient is the client API for StreamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Stream Service
// ============================================================================
type StreamServiceClient interface {
	CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error)
	GetStream(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetStreamResponse, error)
	ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error)
	UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*UpdateStreamResponse, error)
	DeleteStream(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	EndStream(ctx context.Context, in *EndStreamRequest, opts ...grpc.CallOption) (*EndStreamResponse, error)
	GetActiveStream(ctx context.Context, in *GetActiveStreamRequest, opts ...grpc.CallOption) (*GetActiveStreamResponse, error)
	GetStreamStats(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetStreamStatsResponse, error)
}

type streamServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamServiceClient(cc grpc.ClientConnInterface) StreamServiceClient {
	return &streamServiceClient{cc}
}

func (c *streamServiceClient) CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_CreateStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetStream(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_GetStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStreamsResponse)
	err := c.cc.Invoke(ctx, StreamService_ListStreams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*UpdateStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_UpdateStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) DeleteStream(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, StreamService_DeleteStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) EndStream(ctx context.Context, in *EndStreamRequest, opts ...grpc.CallOption) (*EndStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_EndStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetActiveStream(ctx context.Context, in *GetActiveStreamRequest, opts ...grpc.CallOption) (*GetActiveStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_GetActiveStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetStreamStats(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetStreamStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamStatsResponse)
	err := c.cc.Invoke(ctx, StreamService_GetStreamStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamServiceServer is the server API for StreamService service.
// All implementations must embed UnimplementedStreamServiceServer
// for forward compatibility.
//
// ============================================================================
// Stream Service
// ============================================================================
type StreamServiceServer interface {
	CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error)
	GetStream(context.Context, *IdRequest) (*GetStreamResponse, error)
	ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error)
	UpdateStream(context.Context, *UpdateStreamRequest) (*UpdateStreamResponse, error)
	DeleteStream(context.Context, *IdRequest) (*DeleteResponse, error)
	EndStream(context.Context, *EndStreamRequest) (*EndStreamResponse, error)
	GetActiveStream(context.Context, *GetActiveStreamRequest) (*GetActiveStreamResponse, error)
	GetStreamStats(context.Context, *IdRequest) (*GetStreamStatsResponse, error)
	mustEmbedUnimplementedStreamServiceServer()
}

// UnimplementedStreamServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamServiceServer struct{}

func (UnimplementedStreamServiceServer) CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStream not implemented")
}
func (UnimplementedStreamServiceServer) GetStream(context.Context, *IdRequest) (*GetStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStream not implemented")
}
func (UnimplementedStreamServiceServer) ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStreams not implemented")
}
func (UnimplementedStreamServiceServer) UpdateStream(context.Context, *UpdateStreamRequest) (*UpdateStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStream not implemented")
}
func (UnimplementedStreamServiceServer) DeleteStream(context.Context, *IdRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStream not implemented")
}
func (UnimplementedStreamServiceServer) EndStream(context.Context, *EndStreamRequest) (*EndStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndStream not implemented")
}
func (UnimplementedStreamServiceServer) GetActiveStream(context.Context, *GetActiveStreamRequest) (*GetActiveStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveStream not implemented")
}
func (UnimplementedStreamServiceServer) GetStreamStats(context.Context, *IdRequest) (*GetStreamStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStreamStats not implemented")
}
func (UnimplementedStreamServiceServer) mustEmbedUnimplementedStreamServiceServer() {}
func (UnimplementedStreamServiceServer) testEmbeddedByValue()                       {}

// UnsafeStreamServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamServiceServer will
// result in compilation errors.
type UnsafeStreamServiceServer interface {
	mustEmbedUnimplementedStreamServiceServer()
}

func RegisterStreamServiceServer(s grpc.ServiceRegistrar, srv StreamServiceServer) {
	// If the following call pancis, it indicates UnimplementedStreamServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamService_ServiceDesc, srv)
}

func _StreamService_CreateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).CreateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_CreateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).CreateStream(ctx, req.(*CreateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetStream(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_ListStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).ListStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_ListStreams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).ListStreams(ctx, req.(*ListStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_UpdateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).UpdateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_UpdateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).UpdateStream(ctx, req.(*UpdateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_DeleteStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).DeleteStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_DeleteStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).DeleteStream(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_EndStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).EndStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_EndStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).EndStream(ctx, req.(*EndStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetActiveStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetActiveStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetActiveStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetActiveStream(ctx, req.(*GetActiveStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetStreamStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetStreamStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetStreamStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetStreamStats(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamService_ServiceDesc is the grpc.ServiceDesc for StreamService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.StreamService",
	HandlerType: (*StreamServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStream",
			Handler:    _StreamService_CreateStream_Handler,
		},
		{
			MethodName: "GetStream",
			Handler:    _StreamService_GetStream_Handler,
		},
		{
			MethodName: "ListStreams",
			Handler:    _StreamService_ListStreams_Handler,
		},
		{
			MethodName: "UpdateStream",
			Handler:    _StreamService_UpdateStream_Handler,
		},
		{
			MethodName: "DeleteStream",
			Handler:    _StreamService_DeleteStream_Handler,
		},
		{
			MethodName: "EndStream",
			Handler:    _StreamService_EndStream_Handler,
		},
		{
			MethodName: "GetActiveStream",
			Handler:    _StreamService_GetActiveStream_Handler,
		},
		{
			MethodName: "GetStreamStats",
			Handler:    _StreamService_GetStreamStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	MessageService_CreateMessage_FullMethodName   = "/twitchbot.MessageService/CreateMessage"
	MessageService_GetMessage_FullMethodName      = "/twitchbot.MessageService/GetMessage"
	MessageService_ListMessages_FullMethodName    = "/twitchbot.MessageService/ListMessages"
	MessageService_DeleteMessage_FullMethodName   = "/twitchbot.MessageService/DeleteMessage"
	MessageService_SearchMessages_FullMethodName  = "/twitchbot.MessageService/SearchMessages"
	MessageService_GetMessageStats_FullMethodName = "/twitchbot.MessageService/GetMessageStats"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Message Service
// ============================================================================
type MessageServiceClient interface {
	CreateMessage(ctx context.Context, in *CreateMessageRequest, opts ...grpc.CallOption) (*CreateMessageResponse, error)
	GetMessage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetMessageResponse, error)
	ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error)
	DeleteMessage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	SearchMessages(ctx context.Context, in *SearchMessagesRequest, opts ...grpc.CallOption) (*SearchMessagesResponse, error)
	GetMessageStats(ctx context.Context, in *GetMessageStatsRequest, opts ...grpc.CallOption) (*GetMessageStatsResponse, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) CreateMessage(ctx context.Context, in *CreateMessageRequest, opts ...grpc.CallOption) (*CreateMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMessageResponse)
	err := c.cc.Invoke(ctx, MessageService_CreateMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetMessage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessageResponse)
	err := c.cc.Invoke(ctx, MessageService_GetMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMessagesResponse)
	err := c.cc.Invoke(ctx, MessageService_ListMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) DeleteMessage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, MessageService_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) SearchMessages(ctx context.Context, in *SearchMessagesRequest, opts ...grpc.CallOption) (*SearchMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchMessagesResponse)
	err := c.cc.Invoke(ctx, MessageService_SearchMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetMessageStats(ctx context.Context, in *GetMessageStatsRequest, opts ...grpc.CallOption) (*GetMessageStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessageStatsResponse)
	err := c.cc.Invoke(ctx, MessageService_GetMessageStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
//
// ============================================================================
// Message Service
// ============================================================================
type MessageServiceServer interface {
	CreateMessage(context.Context, *CreateMessageRequest) (*CreateMessageResponse, error)
	GetMessage(context.Context, *IdRequest) (*GetMessageResponse, error)
	ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error)
	DeleteMessage(context.Context, *IdRequest) (*DeleteResponse, error)
	SearchMessages(context.Context, *SearchMessagesRequest) (*SearchMessagesResponse, error)
	GetMessageStats(context.Context, *GetMessageStatsRequest) (*GetMessageStatsResponse, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) CreateMessage(context.Context, *CreateMessageRequest) (*CreateMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMessage not implemented")
}
func (UnimplementedMessageServiceServer) GetMessage(context.Context, *IdRequest) (*GetMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessage not implemented")
}
func (UnimplementedMessageServiceServer) ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMessages not implemented")
}
func (UnimplementedMessageServiceServer) DeleteMessage(context.Context, *IdRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedMessageServiceServer) SearchMessages(context.Context, *SearchMessagesRequest) (*SearchMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchMessages not implemented")
}
func (UnimplementedMessageServiceServer) GetMessageStats(context.Context, *GetMessageStatsRequest) (*GetMessageStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessageStats not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call pancis, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_CreateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).CreateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_CreateMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).CreateMessage(ctx, req.(*CreateMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_GetMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetMessage(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_ListMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).ListMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_ListMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).ListMessages(ctx, req.(*ListMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).DeleteMessage(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_SearchMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).SearchMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_SearchMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).SearchMessages(ctx, req.(*SearchMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetMessageStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetMessageStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_GetMessageStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetMessageStats(ctx, req.(*GetMessageStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMessage",
			Handler:    _MessageService_CreateMessage_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _MessageService_GetMessage_Handler,
		},
		{
			MethodName: "ListMessages",
			Handler:    _MessageService_ListMessages_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _MessageService_DeleteMessage_Handler,
		},
		{
			MethodName: "SearchMessages",
			Handler:    _MessageService_SearchMessages_Handler,
		},
		{
			MethodName: "GetMessageStats",
			Handler:    _MessageService_GetMessageStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	ViewerService_CreateViewer_FullMethodName        = "/twitchbot.ViewerService/CreateViewer"
	ViewerService_GetViewer_FullMethodName           = "/twitchbot.ViewerService/GetViewer"
	ViewerService_ListViewers_FullMethodName         = "/twitchbot.ViewerService/ListViewers"
	ViewerService_UpdateViewer_FullMethodName        = "/twitchbot.ViewerService/UpdateViewer"
	ViewerService_DeleteViewer_FullMethodName        = "/twitchbot.ViewerService/DeleteViewer"
	ViewerService_GetViewerByTwitchId_FullMethodName = "/twitchbot.ViewerService/GetViewerByTwitchId"
	ViewerService_GetViewerStats_FullMethodName      = "/twitchbot.ViewerService/GetViewerStats"
)

// ViewerServiceClient is the client API for ViewerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Viewer Service
// ============================================================================
type ViewerServiceClient interface {
	CreateViewer(ctx context.Context, in *CreateViewerRequest, opts ...grpc.CallOption) (*CreateViewerResponse, error)
	GetViewer(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetViewerResponse, error)
	ListViewers(ctx context.Context, in *ListViewersRequest, opts ...grpc.CallOption) (*ListViewersResponse, error)
	UpdateViewer(ctx context.Context, in *UpdateViewerRequest, opts ...grpc.CallOption) (*UpdateViewerResponse, error)
	DeleteViewer(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	GetViewerByTwitchId(ctx context.Context, in *GetViewerByTwitchIdRequest, opts ...grpc.CallOption) (*GetViewerResponse, error)
	GetViewerStats(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetViewerStatsResponse, error)
}

type viewerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerServiceClient(cc grpc.ClientConnInterface) ViewerServiceClient {
	return &viewerServiceClient{cc}
}

func (c *viewerServiceClient) CreateViewer(ctx context.Context, in *CreateViewerRequest, opts ...grpc.CallOption) (*CreateViewerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateViewerResponse)
	err := c.cc.Invoke(ctx, ViewerService_CreateViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) GetViewer(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetViewerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerResponse)
	err := c.cc.Invoke(ctx, ViewerService_GetViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) ListViewers(ctx context.Context, in *ListViewersRequest, opts ...grpc.CallOption) (*ListViewersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListViewersResponse)
	err := c.cc.Invoke(ctx, ViewerService_ListViewers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) UpdateViewer(ctx context.Context, in *UpdateViewerRequest, opts ...grpc.CallOption) (*UpdateViewerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateViewerResponse)
	err := c.cc.Invoke(ctx, ViewerService_UpdateViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) DeleteViewer(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, ViewerService_DeleteViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) GetViewerByTwitchId(ctx context.Context, in *GetViewerByTwitchIdRequest, opts ...grpc.CallOption) (*GetViewerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerResponse)
	err := c.cc.Invoke(ctx, ViewerService_GetViewerByTwitchId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) GetViewerStats(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetViewerStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerStatsResponse)
	err := c.cc.Invoke(ctx, ViewerService_GetViewerStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerServiceServer is the server API for ViewerService service.
// All implementations must embed UnimplementedViewerServiceServer
// for forward compatibility.
//
// ============================================================================
// Viewer Service
// ============================================================================
type ViewerServiceServer interface {
	CreateViewer(context.Context, *CreateViewerRequest) (*CreateViewerResponse, error)
	GetViewer(context.Context, *IdRequest) (*GetViewerResponse, error)
	ListViewers(context.Context, *ListViewersRequest) (*ListViewersResponse, error)
	UpdateViewer(context.Context, *UpdateViewerRequest) (*UpdateViewerResponse, error)
	DeleteViewer(context.Context, *IdRequest) (*DeleteResponse, error)
	GetViewerByTwitchId(context.Context, *GetViewerByTwitchIdRequest) (*GetViewerResponse, error)
	GetViewerStats(context.Context, *IdRequest) (*GetViewerStatsResponse, error)
	mustEmbedUnimplementedViewerServiceServer()
}

// UnimplementedViewerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedViewerServiceServer struct{}

func (UnimplementedViewerServiceServer) CreateViewer(context.Context, *CreateViewerRequest) (*CreateViewerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateViewer not implemented")
}
func (UnimplementedViewerServiceServer) GetViewer(context.Context, *IdRequest) (*GetViewerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetViewer not implemented")
}
func (UnimplementedViewerServiceServer) ListViewers(context.Context, *ListViewersRequest) (*ListViewersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListViewers not implemented")
}
func (UnimplementedViewerServiceServer) UpdateViewer(context.Context, *UpdateViewerRequest) (*UpdateViewerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateViewer not implemented")
}
func (UnimplementedViewerServiceServer) DeleteViewer(context.Context, *IdRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteViewer not implemented")
}
func (UnimplementedViewerServiceServer) GetViewerByTwitchId(context.Context, *GetViewerByTwitchIdRequest) (*GetViewerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetViewerByTwitchId not implemented")
}
func (UnimplementedViewerServiceServer) GetViewerStats(context.Context, *IdRequest) (*GetViewerStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetViewerStats not implemented")
}
func (UnimplementedViewerServiceServer) mustEmbedUnimplementedViewerServiceServer() {}
func (UnimplementedViewerServiceServer) testEmbeddedByValue()                       {}

// UnsafeViewerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerServiceServer will
// result in compilation errors.
type UnsafeViewerServiceServer interface {
	mustEmbedUnimplementedViewerServiceServer()
}

func RegisterViewerServiceServer(s grpc.ServiceRegistrar, srv ViewerServiceServer) {
	// If the following call pancis, it indicates UnimplementedViewerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ViewerService_ServiceDesc, srv)
}

func _ViewerService_CreateViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateViewerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).CreateViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_CreateViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).CreateViewer(ctx, req.(*CreateViewerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_GetViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).GetViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_GetViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).GetViewer(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_ListViewers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListViewersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).ListViewers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_ListViewers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).ListViewers(ctx, req.(*ListViewersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_UpdateViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateViewerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).UpdateViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_UpdateViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).UpdateViewer(ctx, req.(*UpdateViewerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_DeleteViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).DeleteViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_DeleteViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).DeleteViewer(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_GetViewerByTwitchId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewerByTwitchIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).GetViewerByTwitchId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_GetViewerByTwitchId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).GetViewerByTwitchId(ctx, req.(*GetViewerByTwitchIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_GetViewerStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).GetViewerStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_GetViewerStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).GetViewerStats(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerService_ServiceDesc is the grpc.ServiceDesc for ViewerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.ViewerService",
	HandlerType: (*ViewerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateViewer",
			Handler:    _ViewerService_CreateViewer_Handler,
		},
		{
			MethodName: "GetViewer",
			Handler:    _ViewerService_GetViewer_Handler,
		},
		{
			MethodName: "ListViewers",
			Handler:    _ViewerService_ListViewers_Handler,
		},
		{
			MethodName: "UpdateViewer",
			Handler:    _ViewerService_UpdateViewer_Handler,
		},
		{
			MethodName: "DeleteViewer",
			Handler:    _ViewerService_DeleteViewer_Handler,
		},
		{
			MethodName: "GetViewerByTwitchId",
			Handler:    _ViewerService_GetViewerByTwitchId_Handler,
		},
		{
			MethodName: "GetViewerStats",
			Handler:    _ViewerService_GetViewerStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	ClipService_CreateClip_FullMethodName        = "/twitchbot.ClipService/CreateClip"
	ClipService_GetClip_FullMethodName           = "/twitchbot.ClipService/GetClip"
	ClipService_ListClips_FullMethodName         = "/twitchbot.ClipService/ListClips"
	ClipService_UpdateClip_FullMethodName        = "/twitchbot.ClipService/UpdateClip"
	ClipService_DeleteClip_FullMethodName        = "/twitchbot.ClipService/DeleteClip"
	ClipService_GetClipByTwitchId_FullMethodName = "/twitchbot.ClipService/GetClipByTwitchId"
)

// ClipServiceClient is the client API for ClipService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Clip Service
// ============================================================================
type ClipServiceClient interface {
	CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error)
	GetClip(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetClipResponse, error)
	ListClips(ctx context.Context, in *ListClipsRequest, opts ...grpc.CallOption) (*ListClipsResponse, error)
	UpdateClip(ctx context.Context, in *UpdateClipRequest, opts ...grpc.CallOption) (*UpdateClipResponse, error)
	DeleteClip(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	GetClipByTwitchId(ctx context.Context, in *GetClipByTwitchIdRequest, opts ...grpc.CallOption) (*GetClipResponse, error)
}

type clipServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipServiceClient(cc grpc.ClientConnInterface) ClipServiceClient {
	return &clipServiceClient{cc}
}

func (c *clipServiceClient) CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClipResponse)
	err := c.cc.Invoke(ctx, ClipService_CreateClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClip(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClipResponse)
	err := c.cc.Invoke(ctx, ClipService_GetClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) ListClips(ctx context.Context, in *ListClipsRequest, opts ...grpc.CallOption) (*ListClipsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClipsResponse)
	err := c.cc.Invoke(ctx, ClipService_ListClips_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) UpdateClip(ctx context.Context, in *UpdateClipRequest, opts ...grpc.CallOption) (*UpdateClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateClipResponse)
	err := c.cc.Invoke(ctx, ClipService_UpdateClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) DeleteClip(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, ClipService_DeleteClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClipByTwitchId(ctx context.Context, in *GetClipByTwitchIdRequest, opts ...grpc.CallOption) (*GetClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClipResponse)
	err := c.cc.Invoke(ctx, ClipService_GetClipByTwitchId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipServiceServer is the server API for ClipService service.
// All implementations must embed UnimplementedClipServiceServer
// for forward compatibility.
//
// ============================================================================
// Clip Service
// ============================================================================
type ClipServiceServer interface {
	CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error)
	GetClip(context.Context, *IdRequest) (*GetClipResponse, error)
	ListClips(context.Context, *ListClipsRequest) (*ListClipsResponse, error)
	UpdateClip(context.Context, *UpdateClipRequest) (*UpdateClipResponse, error)
	DeleteClip(context.Context, *IdRequest) (*DeleteResponse, error)
	GetClipByTwitchId(context.Context, *GetClipByTwitchIdRequest) (*GetClipResponse, error)
	mustEmbedUnimplementedClipServiceServer()
}

// UnimplementedClipServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClipServiceServer struct{}

func (UnimplementedClipServiceServer) CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClip not implemented")
}
func (UnimplementedClipServiceServer) GetClip(context.Context, *IdRequest) (*GetClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClip not implemented")
}
func (UnimplementedClipServiceServer) ListClips(context.Context, *ListClipsRequest) (*ListClipsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClips not implemented")
}
func (UnimplementedClipServiceServer) UpdateClip(context.Context, *UpdateClipRequest) (*UpdateClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClip not implemented")
}
func (UnimplementedClipServiceServer) DeleteClip(context.Context, *IdRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClip not implemented")
}
func (UnimplementedClipServiceServer) GetClipByTwitchId(context.Context, *GetClipByTwitchIdRequest) (*GetClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClipByTwitchId not implemented")
}
func (UnimplementedClipServiceServer) mustEmbedUnimplementedClipServiceServer() {}
func (UnimplementedClipServiceServer) testEmbeddedByValue()                     {}

// UnsafeClipServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipServiceServer will
// result in compilation errors.
type UnsafeClipServiceServer interface {
	mustEmbedUnimplementedClipServiceServer()
}

func RegisterClipServiceServer(s grpc.ServiceRegistrar, srv ClipServiceServer) {
	// If the following call pancis, it indicates UnimplementedClipServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClipService_ServiceDesc, srv)
}

func _ClipService_CreateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).CreateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_CreateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).CreateClip(ctx, req.(*CreateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClip(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_ListClips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClipsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).ListClips(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_ListClips_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).ListClips(ctx, req.(*ListClipsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_UpdateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).UpdateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_UpdateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).UpdateClip(ctx, req.(*UpdateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_DeleteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).DeleteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_DeleteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).DeleteClip(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClipByTwitchId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipByTwitchIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClipByTwitchId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClipByTwitchId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClipByTwitchId(ctx, req.(*GetClipByTwitchIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipService_ServiceDesc is the grpc.ServiceDesc for ClipService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.ClipService",
	HandlerType: (*ClipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClip",
			Handler:    _ClipService_CreateClip_Handler,
		},
		{
			MethodName: "GetClip",
			Handler:    _ClipService_GetClip_Handler,
		},
		{
			MethodName: "ListClips",
			Handler:    _ClipService_ListClips_Handler,
		},
		{
			MethodName: "UpdateClip",
			Handler:    _ClipService_UpdateClip_Handler,
		},
		{
			MethodName: "DeleteClip",
			Handler:    _ClipService_DeleteClip_Handler,
		},
		{
			MethodName: "GetClipByTwitchId",
			Handler:    _ClipService_GetClipByTwitchId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	CommandService_CreateCommand_FullMethodName    = "/twitchbot.CommandService/CreateCommand"
	CommandService_GetCommand_FullMethodName       = "/twitchbot.CommandService/GetCommand"
	CommandService_ListCommands_FullMethodName     = "/twitchbot.CommandService/ListCommands"
	CommandService_UpdateCommand_FullMethodName    = "/twitchbot.CommandService/UpdateCommand"
	CommandService_DeleteCommand_FullMethodName    = "/twitchbot.CommandService/DeleteCommand"
	CommandService_GetCommandByName_FullMethodName = "/twitchbot.CommandService/GetCommandByName"
	CommandService_ExecuteCommand_FullMethodName   = "/twitchbot.CommandService/ExecuteCommand"
)

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Command Service
// ============================================================================
type CommandServiceClient interface {
	CreateCommand(ctx context.Context, in *CreateCommandRequest, opts ...grpc.CallOption) (*CreateCommandResponse, error)
	GetCommand(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetCommandResponse, error)
	ListCommands(ctx context.Context, in *ListCommandsRequest, opts ...grpc.CallOption) (*ListCommandsResponse, error)
	UpdateCommand(ctx context.Context, in *UpdateCommandRequest, opts ...grpc.CallOption) (*UpdateCommandResponse, error)
	DeleteCommand(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	GetCommandByName(ctx context.Context, in *GetCommandByNameRequest, opts ...grpc.CallOption) (*GetCommandResponse, error)
	ExecuteCommand(ctx context.Context, in *ExecuteCommandRequest, opts ...grpc.CallOption) (*ExecuteCommandResponse, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) CreateCommand(ctx context.Context, in *CreateCommandRequest, opts ...grpc.CallOption) (*CreateCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCommandResponse)
	err := c.cc.Invoke(ctx, CommandService_CreateCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) GetCommand(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*GetCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommandResponse)
	err := c.cc.Invoke(ctx, CommandService_GetCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ListCommands(ctx context.Context, in *ListCommandsRequest, opts ...grpc.CallOption) (*ListCommandsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCommandsResponse)
	err := c.cc.Invoke(ctx, CommandService_ListCommands_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) UpdateCommand(ctx context.Context, in *UpdateCommandRequest, opts ...grpc.CallOption) (*UpdateCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCommandResponse)
	err := c.cc.Invoke(ctx, CommandService_UpdateCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteCommand(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, CommandService_DeleteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) GetCommandByName(ctx context.Context, in *GetCommandByNameRequest, opts ...grpc.CallOption) (*GetCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommandResponse)
	err := c.cc.Invoke(ctx, CommandService_GetCommandByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ExecuteCommand(ctx context.Context, in *ExecuteCommandRequest, opts ...grpc.CallOption) (*ExecuteCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteCommandResponse)
	err := c.cc.Invoke(ctx, CommandService_ExecuteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
// All implementations must embed UnimplementedCommandServiceServer
// for forward compatibility.
//
// ============================================================================
// Command Service
// ============================================================================
type CommandServiceServer interface {
	CreateCommand(context.Context, *CreateCommandRequest) (*CreateCommandResponse, error)
	GetCommand(context.Context, *IdRequest) (*GetCommandResponse, error)
	ListCommands(context.Context, *ListCommandsRequest) (*ListCommandsResponse, error)
	UpdateCommand(context.Context, *UpdateCommandRequest) (*UpdateCommandResponse, error)
	DeleteCommand(context.Context, *IdRequest) (*DeleteResponse, error)
	GetCommandByName(context.Context, *GetCommandByNameRequest) (*GetCommandResponse, error)
	ExecuteCommand(context.Context, *ExecuteCommandRequest) (*ExecuteCommandResponse, error)
	mustEmbedUnimplementedCommandServiceServer()
}

// UnimplementedCommandServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommandServiceServer struct{}

func (UnimplementedCommandServiceServer) CreateCommand(context.Context, *CreateCommandRequest) (*CreateCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCommand not implemented")
}
func (UnimplementedCommandServiceServer) GetCommand(context.Context, *IdRequest) (*GetCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommand not implemented")
}
func (UnimplementedCommandServiceServer) ListCommands(context.Context, *ListCommandsRequest) (*ListCommandsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommands not implemented")
}
func (UnimplementedCommandServiceServer) UpdateCommand(context.Context, *UpdateCommandRequest) (*UpdateCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCommand not implemented")
}
func (UnimplementedCommandServiceServer) DeleteCommand(context.Context, *IdRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommand not implemented")
}
func (UnimplementedCommandServiceServer) GetCommandByName(context.Context, *GetCommandByNameRequest) (*GetCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommandByName not implemented")
}
func (UnimplementedCommandServiceServer) ExecuteCommand(context.Context, *ExecuteCommandRequest) (*ExecuteCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteCommand not implemented")
}
func (UnimplementedCommandServiceServer) mustEmbedUnimplementedCommandServiceServer() {}
func (UnimplementedCommandServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	// If the following call pancis, it indicates UnimplementedCommandServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommandService_ServiceDesc, srv)
}

func _CommandService_CreateCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CreateCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_CreateCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CreateCommand(ctx, req.(*CreateCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_GetCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).GetCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_GetCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).GetCommand(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ListCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ListCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_ListCommands_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ListCommands(ctx, req.(*ListCommandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_UpdateCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).UpdateCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_UpdateCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).UpdateCommand(ctx, req.(*UpdateCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteCommand(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_GetCommandByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommandByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).GetCommandByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_GetCommandByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).GetCommandByName(ctx, req.(*GetCommandByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ExecuteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_ExecuteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ExecuteCommand(ctx, req.(*ExecuteCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommandService_ServiceDesc is the grpc.ServiceDesc for CommandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCommand",
			Handler:    _CommandService_CreateCommand_Handler,
		},
		{
			MethodName: "GetCommand",
			Handler:    _CommandService_GetCommand_Handler,
		},
		{
			MethodName: "ListCommands",
			Handler:    _CommandService_ListCommands_Handler,
		},
		{
			MethodName: "UpdateCommand",
			Handler:    _CommandService_UpdateCommand_Handler,
		},
		{
			MethodName: "DeleteCommand",
			Handler:    _CommandService_DeleteCommand_Handler,
		},
		{
			MethodName: "GetCommandByName",
			Handler:    _CommandService_GetCommandByName_Handler,
		},
		{
			MethodName: "ExecuteCommand",
			Handler:    _CommandService_ExecuteCommand_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	BotService_JoinChannel_FullMethodName  = "/twitchbot.BotService/JoinChannel"
	BotService_LeaveChannel_FullMethodName = "/twitchbot.BotService/LeaveChannel"
	BotService_ListChannels_FullMethodName = "/twitchbot.BotService/ListChannels"
	BotService_GetBotStatus_FullMethodName = "/twitchbot.BotService/GetBotStatus"
	BotService_SendMessage_FullMethodName  = "/twitchbot.BotService/SendMessage"
)

// BotServiceClient is the client API for BotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BotServiceClient interface {
	// Join a channel
	JoinChannel(ctx context.Context, in *JoinChannelRequest, opts ...grpc.CallOption) (*JoinChannelResponse, error)
	// Leave a channel
	LeaveChannel(ctx context.Context, in *LeaveChannelRequest, opts ...grpc.CallOption) (*LeaveChannelResponse, error)
	// List all joined channels
	ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)
	// Get bot status
	GetBotStatus(ctx context.Context, in *GetBotStatusRequest, opts ...grpc.CallOption) (*GetBotStatusResponse, error)
	// Send a message to a channel
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
}

type botServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBotServiceClient(cc grpc.ClientConnInterface) BotServiceClient {
	return &botServiceClient{cc}
}

func (c *botServiceClient) JoinChannel(ctx context.Context, in *JoinChannelRequest, opts ...grpc.CallOption) (*JoinChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinChannelResponse)
	err := c.cc.Invoke(ctx, BotService_JoinChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botServiceClient) LeaveChannel(ctx context.Context, in *LeaveChannelRequest, opts ...grpc.CallOption) (*LeaveChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveChannelResponse)
	err := c.cc.Invoke(ctx, BotService_LeaveChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botServiceClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListChannelsResponse)
	err := c.cc.Invoke(ctx, BotService_ListChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botServiceClient) GetBotStatus(ctx context.Context, in *GetBotStatusRequest, opts ...grpc.CallOption) (*GetBotStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBotStatusResponse)
	err := c.cc.Invoke(ctx, BotService_GetBotStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, BotService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BotServiceServer is the server API for BotService service.
// All implementations must embed UnimplementedBotServiceServer
// for forward compatibility.
type BotServiceServer interface {
	// Join a channel
	JoinChannel(context.Context, *JoinChannelRequest) (*JoinChannelResponse, error)
	// Leave a channel
	LeaveChannel(context.Context, *LeaveChannelRequest) (*LeaveChannelResponse, error)
	// List all joined channels
	ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)
	// Get bot status
	GetBotStatus(context.Context, *GetBotStatusRequest) (*GetBotStatusResponse, error)
	// Send a message to a channel
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	mustEmbedUnimplementedBotServiceServer()
}

// UnimplementedBotServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBotServiceServer struct{}

func (UnimplementedBotServiceServer) JoinChannel(context.Context, *JoinChannelRequest) (*JoinChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinChannel not implemented")
}
func (UnimplementedBotServiceServer) LeaveChannel(context.Context, *LeaveChannelRequest) (*LeaveChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveChannel not implemented")
}
func (UnimplementedBotServiceServer) ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChannels not implemented")
}
func (UnimplementedBotServiceServer) GetBotStatus(context.Context, *GetBotStatusRequest) (*GetBotStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBotStatus not implemented")
}
func (UnimplementedBotServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedBotServiceServer) mustEmbedUnimplementedBotServiceServer() {}
func (UnimplementedBotServiceServer) testEmbeddedByValue()                    {}

// UnsafeBotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BotServiceServer will
// result in compilation errors.
type UnsafeBotServiceServer interface {
	mustEmbedUnimplementedBotServiceServer()
}

func RegisterBotServiceServer(s grpc.ServiceRegistrar, srv BotServiceServer) {
	// If the following call pancis, it indicates UnimplementedBotServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BotService_ServiceDesc, srv)
}

func _BotService_JoinChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotServiceServer).JoinChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BotService_JoinChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotServiceServer).JoinChannel(ctx, req.(*JoinChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BotService_LeaveChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotServiceServer).LeaveChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BotService_LeaveChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotServiceServer).LeaveChannel(ctx, req.(*LeaveChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BotService_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotServiceServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BotService_ListChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotServiceServer).ListChannels(ctx, req.(*ListChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BotService_GetBotStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBotStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotServiceServer).GetBotStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BotService_GetBotStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotServiceServer).GetBotStatus(ctx, req.(*GetBotStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BotService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BotService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BotService_ServiceDesc is the grpc.ServiceDesc for BotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.BotService",
	HandlerType: (*BotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinChannel",
			Handler:    _BotService_JoinChannel_Handler,
		},
		{
			MethodName: "LeaveChannel",
			Handler:    _BotService_LeaveChannel_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _BotService_ListChannels_Handler,
		},
		{
			MethodName: "GetBotStatus",
			Handler:    _BotService_GetBotStatus_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _BotService_SendMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}

const (
	ChannelViewerService_GetChannelViewer_FullMethodName    = "/twitchbot.ChannelViewerService/GetChannelViewer"
	ChannelViewerService_ListChannelViewers_FullMethodName  = "/twitchbot.ChannelViewerService/ListChannelViewers"
	ChannelViewerService_CountChannelViewers_FullMethodName = "/twitchbot.ChannelViewerService/CountChannelViewers"
	ChannelViewerService_RemoveChannelViewer_FullMethodName = "/twitchbot.ChannelViewerService/RemoveChannelViewer"
)

// ChannelViewerServiceClient is the client API for ChannelViewerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// Channel Viewer Service - Track viewers per channel
// ============================================================================
type ChannelViewerServiceClient interface {
	GetChannelViewer(ctx context.Context, in *GetChannelViewerRequest, opts ...grpc.CallOption) (*GetChannelViewerResponse, error)
	ListChannelViewers(ctx context.Context, in *ListChannelViewersRequest, opts ...grpc.CallOption) (*ListChannelViewersResponse, error)
	CountChannelViewers(ctx context.Context, in *CountChannelViewersRequest, opts ...grpc.CallOption) (*CountChannelViewersResponse, error)
	RemoveChannelViewer(ctx context.Context, in *RemoveChannelViewerRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type channelViewerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelViewerServiceClient(cc grpc.ClientConnInterface) ChannelViewerServiceClient {
	return &channelViewerServiceClient{cc}
}

func (c *channelViewerServiceClient) GetChannelViewer(ctx context.Context, in *GetChannelViewerRequest, opts ...grpc.CallOption) (*GetChannelViewerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChannelViewerResponse)
	err := c.cc.Invoke(ctx, ChannelViewerService_GetChannelViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelViewerServiceClient) ListChannelViewers(ctx context.Context, in *ListChannelViewersRequest, opts ...grpc.CallOption) (*ListChannelViewersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListChannelViewersResponse)
	err := c.cc.Invoke(ctx, ChannelViewerService_ListChannelViewers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelViewerServiceClient) CountChannelViewers(ctx context.Context, in *CountChannelViewersRequest, opts ...grpc.CallOption) (*CountChannelViewersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountChannelViewersResponse)
	err := c.cc.Invoke(ctx, ChannelViewerService_CountChannelViewers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelViewerServiceClient) RemoveChannelViewer(ctx context.Context, in *RemoveChannelViewerRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, ChannelViewerService_RemoveChannelViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelViewerServiceServer is the server API for ChannelViewerService service.
// All implementations must embed UnimplementedChannelViewerServiceServer
// for forward compatibility.
//
// ============================================================================
// Channel Viewer Service - Track viewers per channel
// ============================================================================
type ChannelViewerServiceServer interface {
	GetChannelViewer(context.Context, *GetChannelViewerRequest) (*GetChannelViewerResponse, error)
	ListChannelViewers(context.Context, *ListChannelViewersRequest) (*ListChannelViewersResponse, error)
	CountChannelViewers(context.Context, *CountChannelViewersRequest) (*CountChannelViewersResponse, error)
	RemoveChannelViewer(context.Context, *RemoveChannelViewerRequest) (*DeleteResponse, error)
	mustEmbedUnimplementedChannelViewerServiceServer()
}

// UnimplementedChannelViewerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChannelViewerServiceServer struct{}

func (UnimplementedChannelViewerServiceServer) GetChannelViewer(context.Context, *GetChannelViewerRequest) (*GetChannelViewerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelViewer not implemented")
}
func (UnimplementedChannelViewerServiceServer) ListChannelViewers(context.Context, *ListChannelViewersRequest) (*ListChannelViewersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChannelViewers not implemented")
}
func (UnimplementedChannelViewerServiceServer) CountChannelViewers(context.Context, *CountChannelViewersRequest) (*CountChannelViewersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountChannelViewers not implemented")
}
func (UnimplementedChannelViewerServiceServer) RemoveChannelViewer(context.Context, *RemoveChannelViewerRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveChannelViewer not implemented")
}
func (UnimplementedChannelViewerServiceServer) mustEmbedUnimplementedChannelViewerServiceServer() {}
func (UnimplementedChannelViewerServiceServer) testEmbeddedByValue()                              {}

// UnsafeChannelViewerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelViewerServiceServer will
// result in compilation errors.
type UnsafeChannelViewerServiceServer interface {
	mustEmbedUnimplementedChannelViewerServiceServer()
}

func RegisterChannelViewerServiceServer(s grpc.ServiceRegistrar, srv ChannelViewerServiceServer) {
	// If the following call pancis, it indicates UnimplementedChannelViewerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChannelViewerService_ServiceDesc, srv)
}

func _ChannelViewerService_GetChannelViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelViewerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelViewerServiceServer).GetChannelViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelViewerService_GetChannelViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelViewerServiceServer).GetChannelViewer(ctx, req.(*GetChannelViewerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelViewerService_ListChannelViewers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelViewersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelViewerServiceServer).ListChannelViewers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelViewerService_ListChannelViewers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelViewerServiceServer).ListChannelViewers(ctx, req.(*ListChannelViewersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelViewerService_CountChannelViewers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountChannelViewersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelViewerServiceServer).CountChannelViewers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelViewerService_CountChannelViewers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelViewerServiceServer).CountChannelViewers(ctx, req.(*CountChannelViewersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelViewerService_RemoveChannelViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveChannelViewerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelViewerServiceServer).RemoveChannelViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelViewerService_RemoveChannelViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelViewerServiceServer).RemoveChannelViewer(ctx, req.(*RemoveChannelViewerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelViewerService_ServiceDesc is the grpc.ServiceDesc for ChannelViewerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelViewerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twitchbot.ChannelViewerService",
	HandlerType: (*ChannelViewerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetChannelViewer",
			Handler:    _ChannelViewerService_GetChannelViewer_Handler,
		},
		{
			MethodName: "ListChannelViewers",
			Handler:    _ChannelViewerService_ListChannelViewers_Handler,
		},
		{
			MethodName: "CountChannelViewers",
			Handler:    _ChannelViewerService_CountChannelViewers_Handler,
		},
		{
			MethodName: "RemoveChannelViewer",
			Handler:    _ChannelViewerService_RemoveChannelViewer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/twitchbot.proto",
}
